<p>When you create a lambda and if the lambda create another lambda in asynchronous way by using thread, you need to be very careful on capturing values. If you capture all variables(including local variables) by references, you will likely make a mistake by using accidentally local variables inside another lambda. If you are lucky application will crash, if not application will corrupt heap in randomly.</p>
<p>You can find similar information from the link(http://stackoverflow.com/questions/6216232/c-nested-lambda-bug-in-vs2010-with-lambda-parameter-capture).</p>
<p>[code lang="c"]<br />
void Func()<br />
{<br />
   FireCall(pEvent, idx + 1, [data](_IEvent* pCall)-&gt;HRESULT<br />
   {<br />
      return pCall-&gt;OnEvent(data);<br />
   });<br />
}</p>
<p>bool FireCall(_IEvent* pEvent, DWORD idx, boost::function&lt;HRESULT(_IEvent*)&gt; func)<br />
{<br />
   IStream* pStream = NULL;<br />
   HRESULT hRes = CoMarshalInterThreadInterfaceInStream(IID__Event, pEvent, &amp;pStream);<br />
   pEvent-&gt;Release();</p>
<p>   // create another lambda, it should pass variable by value.<br />
   m_threadPool.Schedule([idx, pStream]()<br />
   {<br />
       _IEvent* pCallEvent = NULL;<br />
       auto res = CoGetInterfaceAndReleaseStream(pStream, IID, (void**)&amp;pCallEvent);<br />
       if (SUCCEEDED(res))<br />
          func(pCallEvent);<br />
   });<br />
}<br />
[/code]</p>

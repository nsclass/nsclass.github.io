---
layout: single
title: C# example of optimistic concurrency with Entity Framework code first
date: 2013-07-26 08:28:48.000000000 -05:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ".NET"
- Programming
tags: []
meta:
  _edit_last: '14827209'
  _publicize_pending: '1'
  _oembed_3cebac7c77d27dee4c7e925c77f3e8d4: "{{unknown}}"
  _oembed_65add97d8787a2be2d3515fb3e473e4e: "{{unknown}}"
  geo_public: '0'
  _oembed_34fb8921ca6fc20b11fcc19303314196: "{{unknown}}"
  tagazine-media: a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"14827209";s:7:"blog_id";s:8:"14365184";s:9:"mod_stamp";s:19:"2013-07-25
    22:32:12";}
  _oembed_142706fab765ec8376e9f293bc352fab: "{{unknown}}"
  _oembed_9ca77fcfc4ab4f5285d7ee33e84239f2: "{{unknown}}"
author:
  login: acrocontext
  email: nsclass@hotmail.com
  display_name: acrocontext
  first_name: ''
  last_name: ''
permalink: "/2013/07/26/c-example-of-optimistic-concurrency-in-entity-framework/"
---
<p>The following article shows the good example how to use optimistic concurrency control in Entity Framework code first.<br />
http://msdn.microsoft.com/en-us/data/jj592904.aspx</p>
<p>Just in case I would like to copy the code examples from the above page.<br />
Resolving optimistic concurrency exceptions as client wins<br />
[code lang="c"]<br />
using (var context = new BloggingContext())<br />
{<br />
    var blog = context.Blogs.Find(1);<br />
    blog.Name = &quot;The New ADO.NET Blog&quot;;</p>
<p>    bool saveFailed;<br />
    do<br />
    {<br />
        saveFailed = false;<br />
        try<br />
        {<br />
            context.SaveChanges();<br />
        }<br />
        catch (DbUpdateConcurrencyException ex)<br />
        {<br />
            saveFailed = true;</p>
<p>            // Update original values from the database<br />
            var entry = ex.Entries.Single();<br />
            entry.OriginalValues.SetValues(entry.GetDatabaseValues());<br />
        }</p>
<p>    } while (saveFailed);<br />
}<br />
[/code]<br />
Resolving optimistic concurrency exceptions with Reload (database wins)<br />
[code lang="c"]<br />
using (var context = new BloggingContext())<br />
{<br />
    var blog = context.Blogs.Find(1);<br />
    blog.Name = &quot;The New ADO.NET Blog&quot;;</p>
<p>    bool saveFailed;<br />
    do<br />
    {<br />
        saveFailed = false;</p>
<p>        try<br />
        {<br />
            context.SaveChanges();<br />
        }<br />
        catch (DbUpdateConcurrencyException ex)<br />
        {<br />
            saveFailed = true;</p>
<p>            // Update the values of the entity that failed to save from the store<br />
            ex.Entries.Single().Reload();<br />
        }</p>
<p>    } while (saveFailed);<br />
}<br />
[/code]</p>
<p>Custom resolution of optimistic concurrency exceptions<br />
[code lang="c"]<br />
using (var context = new BloggingContext())<br />
{<br />
    var blog = context.Blogs.Find(1);<br />
    blog.Name = &quot;The New ADO.NET Blog&quot;;</p>
<p>    bool saveFailed;<br />
    do<br />
    {<br />
        saveFailed = false;<br />
        try<br />
        {<br />
            context.SaveChanges();<br />
        }<br />
        catch (DbUpdateConcurrencyException ex)<br />
        {<br />
            saveFailed = true;</p>
<p>            // Get the current entity values and the values in the database<br />
            var entry = ex.Entries.Single();<br />
            var currentValues = entry.CurrentValues;<br />
            var databaseValues = entry.GetDatabaseValues();</p>
<p>            // Choose an initial set of resolved values. In this case we<br />
            // make the default be the values currently in the database.<br />
            var resolvedValues = databaseValues.Clone();</p>
<p>            // Have the user choose what the resolved values should be<br />
            HaveUserResolveConcurrency(currentValues, databaseValues, resolvedValues);</p>
<p>            // Update the original values with the database values and<br />
            // the current values with whatever the user choose.<br />
            entry.OriginalValues.SetValues(databaseValues);<br />
            entry.CurrentValues.SetValues(resolvedValues);<br />
        }<br />
    } while (saveFailed);<br />
}</p>
<p>public void HaveUserResolveConcurrency(DbPropertyValues currentValues,<br />
                                       DbPropertyValues databaseValues,<br />
                                       DbPropertyValues resolvedValues)<br />
{<br />
    // Show the current, database, and resolved values to the user and have<br />
    // them edit the resolved values to get the correct resolution.<br />
}<br />
[/code]<br />
Custom resolution of optimistic concurrency exceptions using objects<br />
[code lang="c"]<br />
using (var context = new BloggingContext())<br />
{<br />
    var blog = context.Blogs.Find(1);<br />
    blog.Name = &quot;The New ADO.NET Blog&quot;;</p>
<p>    bool saveFailed;<br />
    do<br />
    {<br />
        saveFailed = false;<br />
        try<br />
        {<br />
            context.SaveChanges();<br />
        }<br />
        catch (DbUpdateConcurrencyException ex)<br />
        {<br />
            saveFailed = true;</p>
<p>            // Get the current entity values and the values in the database<br />
            // as instances of the entity type<br />
            var entry = ex.Entries.Single();<br />
            var databaseValues = entry.GetDatabaseValues();<br />
            var databaseValuesAsBlog = (Blog)databaseValues.ToObject();</p>
<p>            // Choose an initial set of resolved values. In this case we<br />
            // make the default be the values currently in the database.<br />
            var resolvedValuesAsBlog = (Blog)databaseValues.ToObject();</p>
<p>            // Have the user choose what the resolved values should be<br />
            HaveUserResolveConcurrency((Blog)entry.Entity,<br />
                                       databaseValuesAsBlog,<br />
                                       resolvedValuesAsBlog);</p>
<p>            // Update the original values with the database values and<br />
            // the current values with whatever the user choose.<br />
            entry.OriginalValues.SetValues(databaseValues);<br />
            entry.CurrentValues.SetValues(resolvedValuesAsBlog);<br />
        }</p>
<p>    } while (saveFailed);<br />
}</p>
<p>public void HaveUserResolveConcurrency(Blog entity,<br />
                                       Blog databaseValues,<br />
                                       Blog resolvedValues)<br />
{<br />
    // Show the current, database, and resolved values to the user and have<br />
    // them update the resolved values to get the correct resolution.<br />
}<br />
[/code]</p>
